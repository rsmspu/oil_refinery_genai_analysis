# -*- coding: utf-8 -*-
"""oil_rig_data_generation_data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NAFIfjoTcuVFRk5nhS9no0LWhyS6AFGh

### Install Packages
"""

pip install Faker

"""### Load Packages"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import random
from faker import Faker
from scipy import signal
from sklearn.preprocessing import MinMaxScaler
import warnings
warnings.filterwarnings('ignore')

"""### Data Generator Functions"""

fake = Faker()
class OilRigDataGenerator:
    def __init__(self, start_date='2024-01-01', months=6):
        self.start_date = pd.to_datetime(start_date)
        self.months = months
        self.end_date = self.start_date + pd.DateOffset(months=months)
        self.freq = '5T'  # 5-minute intervals
        self.time_index = pd.date_range(start=self.start_date, end=self.end_date, freq=self.freq)

        # Equipment configurations
        self.equipment_config = {
            'centrifugal_pump_01': {
                'sensors': ['suction_pressure', 'discharge_pressure', 'flow_rate', 'temperature', 'vibration', 'power'],
                'normal_ranges': {
                    'suction_pressure': (15, 25),    # bar
                    'discharge_pressure': (45, 65),  # bar
                    'flow_rate': (800, 1200),        # m³/h
                    'temperature': (65, 85),         # °C
                    'vibration': (0.5, 2.0),         # mm/s
                    'power': (180, 220)              # kW
                }
            },
            'gas_compressor_01': {
                'sensors': ['inlet_pressure', 'outlet_pressure', 'temperature', 'vibration', 'flow_rate', 'power'],
                'normal_ranges': {
                    'inlet_pressure': (8, 15),       # bar
                    'outlet_pressure': (35, 50),     # bar
                    'temperature': (120, 160),       # °C
                    'vibration': (1.0, 4.0),         # mm/s
                    'flow_rate': (5000, 8000),       # Nm³/h
                    'power': (450, 550)              # kW
                }
            },
            'drilling_motor_01': {
                'sensors': ['rpm', 'torque', 'temperature', 'vibration', 'pressure', 'power'],
                'normal_ranges': {
                    'rpm': (80, 120),                # RPM
                    'torque': (15000, 25000),        # N⋅m
                    'temperature': (80, 120),        # °C
                    'vibration': (2.0, 8.0),         # mm/s
                    'pressure': (200, 350),          # bar
                    'power': (800, 1200)             # kW
                }
            },
            'separator_01': {
                'sensors': ['pressure', 'temperature', 'liquid_level', 'gas_flow', 'liquid_flow'],
                'normal_ranges': {
                    'pressure': (25, 35),            # bar
                    'temperature': (60, 90),         # °C
                    'liquid_level': (30, 70),        # %
                    'gas_flow': (3000, 5000),        # Nm³/h
                    'liquid_flow': (200, 400)        # m³/h
                }
            },
            'generator_01': {
                'sensors': ['voltage', 'current', 'frequency', 'temperature', 'vibration', 'power_output'],
                'normal_ranges': {
                    'voltage': (380, 420),           # V
                    'current': (280, 320),           # A
                    'frequency': (49.8, 50.2),       # Hz
                    'temperature': (70, 100),        # °C
                    'vibration': (0.8, 3.0),         # mm/s
                    'power_output': (180, 250)       # kW
                }
            }
        }

    def generate_base_signal(self, normal_range, length):
        """Generate base signal with daily and seasonal patterns"""
        min_val, max_val = normal_range
        mean_val = (min_val + max_val) / 2
        amplitude = (max_val - min_val) / 4

        # Time arrays
        hours = np.arange(length) * 5 / 60  # Convert 5-min intervals to hours
        days = hours / 24

        # Daily cycle (peak during day shift)
        daily_cycle = 0.15 * amplitude * np.sin(2 * np.pi * hours / 24 + np.pi/3)

        # Weekly cycle (lower activity on weekends)
        weekly_cycle = 0.1 * amplitude * np.sin(2 * np.pi * days / 7)

        # Seasonal trend (slight increase over months)
        seasonal_trend = 0.05 * amplitude * np.sin(2 * np.pi * days / (30 * self.months))

        # Base signal
        base = mean_val + daily_cycle + weekly_cycle + seasonal_trend

        # Add some correlation between related sensors
        base += np.random.normal(0, amplitude * 0.05, length)

        return base

    def add_anomalies(self, signal, equipment_name, sensor_name):
        """Add various types of anomalies to the signal"""
        signal_copy = signal.copy()
        length = len(signal)
        anomaly_log = []

        # Gradual degradation (bearing wear, fouling, etc.)
        if random.random() < 0.7:  # 70% chance of gradual anomaly
            start_point = random.randint(length//4, length//2)
            degradation_rate = random.uniform(0.00001, 0.0001)
            gradual_increase = np.zeros(length)
            gradual_increase[start_point:] = np.cumsum(np.ones(length - start_point) * degradation_rate)

            if sensor_name in ['vibration', 'temperature', 'pressure']:
                signal_copy += gradual_increase * np.mean(signal_copy)
                anomaly_log.append({
                    'timestamp': self.time_index[start_point],
                    'type': 'gradual_degradation',
                    'equipment': equipment_name,
                    'sensor': sensor_name,
                    'description': f'Gradual increase in {sensor_name} starting from {self.time_index[start_point].strftime("%Y-%m-%d %H:%M")}'
                })

        # Sudden spikes/drops (trips, starts, stops)
        n_spikes = random.randint(2, 8)
        for _ in range(n_spikes):
            if random.random() < 0.6:  # 60% chance of spike
                spike_start = random.randint(100, length - 200)
                spike_duration = random.randint(5, 50)  # 25 minutes to 4 hours
                spike_magnitude = random.uniform(1.2, 2.5) if random.random() < 0.7 else random.uniform(0.3, 0.8)

                signal_copy[spike_start:spike_start + spike_duration] *= spike_magnitude

                anomaly_log.append({
                    'timestamp': self.time_index[spike_start],
                    'type': 'sudden_spike' if spike_magnitude > 1 else 'sudden_drop',
                    'equipment': equipment_name,
                    'sensor': sensor_name,
                    'description': f'{"Spike" if spike_magnitude > 1 else "Drop"} in {sensor_name} at {self.time_index[spike_start].strftime("%Y-%m-%d %H:%M")}, duration: {spike_duration*5} minutes'
                })

        # Oscillations (mechanical looseness, control issues)
        if random.random() < 0.3:  # 30% chance
            osc_start = random.randint(length//3, 2*length//3)
            osc_duration = random.randint(200, 1000)  # 16 hours to 3.5 days
            osc_end = min(osc_start + osc_duration, length)

            osc_freq = random.uniform(0.01, 0.1)  # Cycles per 5-minute interval
            osc_amplitude = np.mean(signal_copy) * random.uniform(0.05, 0.15)
            oscillation = osc_amplitude * np.sin(2 * np.pi * osc_freq * np.arange(osc_end - osc_start))

            signal_copy[osc_start:osc_end] += oscillation

            anomaly_log.append({
                'timestamp': self.time_index[osc_start],
                'type': 'oscillation',
                'equipment': equipment_name,
                'sensor': sensor_name,
                'description': f'Oscillatory behavior in {sensor_name} starting {self.time_index[osc_start].strftime("%Y-%m-%d %H:%M")}'
            })

        return signal_copy, anomaly_log

    def add_noise_and_missing(self, signal, missing_rate=0.02):
        """Add realistic noise and missing values"""
        # Add measurement noise
        noise_std = np.std(signal) * 0.02  # 2% of signal std
        signal += np.random.normal(0, noise_std, len(signal))

        # Add missing values (sensor failures, communication issues)
        missing_mask = np.random.random(len(signal)) < missing_rate

        # Create clusters of missing values (more realistic)
        for i in range(len(missing_mask) - 10):
            if missing_mask[i] and random.random() < 0.7:
                cluster_size = random.randint(2, 20)
                missing_mask[i:i+cluster_size] = True

        signal[missing_mask] = np.nan

        return signal

    def generate_sensor_data(self):
        """Generate all sensor data"""
        all_data = []
        all_anomalies = []

        for equipment_name, config in self.equipment_config.items():
            equipment_data = {'timestamp': self.time_index}

            for sensor_name in config['sensors']:
                normal_range = config['normal_ranges'][sensor_name]

                # Generate base signal
                base_signal = self.generate_base_signal(normal_range, len(self.time_index))

                # Add anomalies
                signal_with_anomalies, anomalies = self.add_anomalies(base_signal, equipment_name, sensor_name)
                all_anomalies.extend(anomalies)

                # Add noise and missing values
                final_signal = self.add_noise_and_missing(signal_with_anomalies)

                # Store in equipment data
                equipment_data[sensor_name] = final_signal

            # Convert to DataFrame
            df = pd.DataFrame(equipment_data)
            df['equipment'] = equipment_name
            all_data.append(df)

        # Combine all equipment data
        sensor_data = pd.concat(all_data, ignore_index=True)
        anomaly_log = pd.DataFrame(all_anomalies)

        return sensor_data, anomaly_log

    def generate_operator_logs(self, n_entries=200):
        """Generate synthetic operator log entries"""

        # Templates for different types of log entries
        maintenance_templates = [
            "Performed routine maintenance on {equipment}. Replaced {component}. All parameters within normal range.",
            "Scheduled inspection of {equipment} completed. {finding}",
            "Lubrication service on {equipment}. {oil_type} oil changed. Next service due in {days} days.",
            "Calibration of {sensor} on {equipment} completed. Adjusted by {adjustment}.",
            "Filter replacement on {equipment}. Old filter showed {condition}.",
        ]

        observation_templates = [
            "Noticed {observation} on {equipment}. {sensor} reading {value}. Continuing to monitor.",
            "Operator reported {issue} during shift change. {equipment} {sensor} shows {trend}.",
            "Unusual {symptom} observed on {equipment}. Maintenance team notified.",
            "Temperature spike detected on {equipment}. Investigated - caused by {cause}.",
            "Vibration levels elevated on {equipment}. Scheduled for detailed inspection.",
        ]

        routine_templates = [
            "Daily rounds completed. All equipment operating normally.",
            "Shift handover: {equipment} running at {percentage}% capacity. No issues reported.",
            "Process parameters stable. Production rate: {rate} units/hour.",
            "Weather conditions: {weather}. All outdoor equipment checked and secure.",
            "Safety check completed. Emergency systems tested and operational.",
        ]

        components = ['bearing', 'seal', 'gasket', 'filter', 'coupling', 'valve', 'sensor', 'cable']
        findings = ['minor wear detected', 'excellent condition', 'within tolerance', 'needs attention next cycle']
        oil_types = ['synthetic', 'mineral', 'bio-degradable']
        observations = ['unusual noise', 'slight vibration increase', 'temperature variation', 'pressure fluctuation']
        issues = ['intermittent alarm', 'slight performance drop', 'minor leak', 'communication error']
        symptoms = ['grinding noise', 'excessive heat', 'erratic readings', 'pressure drop']
        causes = ['ambient temperature change', 'temporary blockage', 'electrical interference', 'process upset']
        weather_conditions = ['clear', 'overcast', 'light rain', 'strong winds', 'fog']

        logs = []
        equipment_names = list(self.equipment_config.keys())

        # Generate entries throughout the time period
        log_timestamps = pd.date_range(
            start=self.start_date,
            end=self.end_date,
            periods=n_entries
        ) + pd.to_timedelta(np.random.randint(0, 24*60, n_entries), unit='m')

        for timestamp in log_timestamps:
            log_type = random.choices(
                ['maintenance', 'observation', 'routine'],
                weights=[0.3, 0.4, 0.3]
            )[0]

            equipment = random.choice(equipment_names)

            if log_type == 'maintenance':
                template = random.choice(maintenance_templates)
                entry = template.format(
                    equipment=equipment,
                    component=random.choice(components),
                    finding=random.choice(findings),
                    oil_type=random.choice(oil_types),
                    days=random.randint(30, 180),
                    sensor=random.choice(self.equipment_config[equipment]['sensors']),
                    adjustment=f"{random.uniform(-5, 5):.1f}%",
                    condition=random.choice(['heavy contamination', 'normal wear', 'minimal debris'])
                )
            elif log_type == 'observation':
                template = random.choice(observation_templates)
                sensor = random.choice(self.equipment_config[equipment]['sensors'])
                sensor_range = self.equipment_config[equipment]['normal_ranges'][sensor]
                value = random.uniform(sensor_range[0] * 0.9, sensor_range[1] * 1.1)

                entry = template.format(
                    observation=random.choice(observations),
                    equipment=equipment,
                    sensor=sensor,
                    value=f"{value:.1f}",
                    issue=random.choice(issues),
                    trend=random.choice(['increasing', 'decreasing', 'fluctuating']),
                    symptom=random.choice(symptoms),
                    cause=random.choice(causes)
                )
            else:  # routine
                template = random.choice(routine_templates)
                entry = template.format(
                    equipment=equipment,
                    percentage=random.randint(75, 100),
                    rate=random.randint(80, 120),
                    weather=random.choice(weather_conditions)
                )

            logs.append({
                'timestamp': timestamp,
                'operator': fake.name(),
                'shift': random.choice(['Day', 'Night', 'Evening']),
                'equipment': equipment if log_type != 'routine' else 'General',
                'log_type': log_type,
                'entry': entry,
                'priority': random.choices(['Low', 'Medium', 'High'], weights=[0.6, 0.3, 0.1])[0]
            })

        return pd.DataFrame(logs).sort_values('timestamp').reset_index(drop=True)

# Example usage and demonstration
def demonstrate_data_generation():
    """Demonstrate the data generation capabilities"""
    print("Generating synthetic oil rig data...")

    # Initialize generator
    generator = OilRigDataGenerator(start_date='2024-01-01', months=3)

    # Generate sensor data
    sensor_data, anomalies = generator.generate_sensor_data()
    print(f"Generated sensor data shape: {sensor_data.shape}")
    print(f"Generated {len(anomalies)} anomaly events")

    # Generate operator logs
    operator_logs = generator.generate_operator_logs(n_entries=100)
    print(f"Generated {len(operator_logs)} operator log entries")

    # Display sample data
    print("\nSample Sensor Data:")
    print(sensor_data.head())

    print("\nSample Anomalies:")
    if len(anomalies) > 0:
        print(anomalies.head())

    print("\nSample Operator Logs:")
    print(operator_logs[['timestamp', 'operator', 'equipment', 'log_type', 'entry']].head())

    # Basic statistics
    print(f"\nData Coverage:")
    print(f"Time range: {sensor_data['timestamp'].min()} to {sensor_data['timestamp'].max()}")
    print(f"Equipment types: {sensor_data['equipment'].nunique()}")
    print(f"Total sensor readings: {sensor_data.shape[0]:,}")

    return sensor_data, anomalies, operator_logs

if __name__ == "__main__":
    sensor_data, anomalies, operator_logs = demonstrate_data_generation()

